/**
 * Particles.js minimal version for Green Coin
 * Inspired by particles.js but simplified for better performance
 */
(function() {
  'use strict';

  const ParticlesJS = function(selector, options) {
    const canvas = document.querySelector(selector);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    let particles = [];
    let animationFrame;

    // Default options
    const defaultOptions = {
      particles: {
        number: {
          value: 80,
          density: {
            enable: true,
            value_area: 800
          }
        },
        color: {
          value: ['#8AFF8A', '#4CAF50', '#FF69B4', '#FF1493']
        },
        size: {
          value: 3,
          random: true,
          min: 1,
          max: 5
        },
        opacity: {
          value: 0.7,
          random: true,
          min: 0.3,
          max: 0.7
        },
        move: {
          enable: true,
          speed: 1,
          direction: 'none',
          random: true,
          straight: false,
          out_mode: 'out'
        },
        line_linked: {
          enable: true,
          distance: 150,
          color: '#4CAF50',
          opacity: 0.4,
          width: 1
        }
      },
      interactivity: {
        detect_on: 'canvas',
        events: {
          onhover: {
            enable: true,
            mode: 'grab'
          },
          onclick: {
            enable: true,
            mode: 'push'
          },
          resize: true
        },
        modes: {
          grab: {
            distance: 140,
            line_linked: {
              opacity: 1
            }
          },
          push: {
            particles_nb: 4
          }
        }
      }
    };

    // Merge options
    const mergedOptions = deepMerge(defaultOptions, options || {});
    const particlesOptions = mergedOptions.particles;
    const interactivityOptions = mergedOptions.interactivity;

    // Mouse position
    let mouseX = 0;
    let mouseY = 0;

    // Resize canvas
    function resizeCanvas() {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      
      // Re-initialize particles
      initParticles();
    }

    // Initialize particles
    function initParticles() {
      particles = [];
      const numberOfParticles = particlesOptions.number.value;
      
      for (let i = 0; i < numberOfParticles; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: particlesOptions.size.random ? 
            Math.random() * (particlesOptions.size.max - particlesOptions.size.min) + particlesOptions.size.min : 
            particlesOptions.size.value,
          color: Array.isArray(particlesOptions.color.value) ? 
            particlesOptions.color.value[Math.floor(Math.random() * particlesOptions.color.value.length)] : 
            particlesOptions.color.value,
          opacity: particlesOptions.opacity.random ? 
            Math.random() * (particlesOptions.opacity.max - particlesOptions.opacity.min) + particlesOptions.opacity.min : 
            particlesOptions.opacity.value,
          speedX: (Math.random() - 0.5) * particlesOptions.move.speed,
          speedY: (Math.random() - 0.5) * particlesOptions.move.speed
        });
      }
    }

    // Draw particles
    function drawParticles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw lines between particles
      if (particlesOptions.line_linked.enable) {
        for (let i = 0; i < particles.length; i++) {
          for (let j = i + 1; j < particles.length; j++) {
            const dx = particles[i].x - particles[j].x;
            const dy = particles[i].y - particles[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < particlesOptions.line_linked.distance) {
              const opacity = particlesOptions.line_linked.opacity - (distance / particlesOptions.line_linked.distance);
              
              ctx.beginPath();
              ctx.moveTo(particles[i].x, particles[i].y);
              ctx.lineTo(particles[j].x, particles[j].y);
              ctx.strokeStyle = `rgba(76, 175, 80, ${opacity})`;
              ctx.lineWidth = particlesOptions.line_linked.width;
              ctx.stroke();
            }
          }
        }
      }
      
      // Draw particles
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${hexToRgb(p.color)}, ${p.opacity})`;
        ctx.fill();
        
        // Move particles
        if (particlesOptions.move.enable) {
          p.x += p.speedX;
          p.y += p.speedY;
          
          // Bounce off edges
          if (p.x < 0 || p.x > canvas.width) p.speedX *= -1;
          if (p.y < 0 || p.y > canvas.height) p.speedY *= -1;
        }
        
        // Interactivity - hover effect
        if (interactivityOptions.events.onhover.enable) {
          const dx = mouseX - p.x;
          const dy = mouseY - p.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < interactivityOptions.modes.grab.distance) {
            // Draw line to mouse
            const opacity = interactivityOptions.modes.grab.line_linked.opacity - (distance / interactivityOptions.modes.grab.distance);
            
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(mouseX, mouseY);
            ctx.strokeStyle = `rgba(255, 20, 147, ${opacity})`;
            ctx.lineWidth = particlesOptions.line_linked.width;
            ctx.stroke();
            
            // Attract particles to mouse
            p.x += dx * 0.01;
            p.y += dy * 0.01;
          }
        }
      }
    }

    // Animation loop
    function animate() {
      drawParticles();
      animationFrame = requestAnimationFrame(animate);
    }

    // Event listeners
    function addEventListeners() {
      window.addEventListener('resize', resizeCanvas);
      
      if (interactivityOptions.events.onhover.enable || interactivityOptions.events.onclick.enable) {
        canvas.addEventListener('mousemove', function(e) {
          const rect = canvas.getBoundingClientRect();
          mouseX = e.clientX - rect.left;
          mouseY = e.clientY - rect.top;
        });
        
        if (interactivityOptions.events.onclick.enable) {
          canvas.addEventListener('click', function() {
            if (interactivityOptions.modes.push.particles_nb > 0) {
              for (let i = 0; i < interactivityOptions.modes.push.particles_nb; i++) {
                particles.push({
                  x: mouseX,
                  y: mouseY,
                  radius: particlesOptions.size.random ? 
                    Math.random() * (particlesOptions.size.max - particlesOptions.size.min) + particlesOptions.size.min : 
                    particlesOptions.size.value,
                  color: Array.isArray(particlesOptions.color.value) ? 
                    particlesOptions.color.value[Math.floor(Math.random() * particlesOptions.color.value.length)] : 
                    particlesOptions.color.value,
                  opacity: particlesOptions.opacity.random ? 
                    Math.random() * (particlesOptions.opacity.max - particlesOptions.opacity.min) + particlesOptions.opacity.min : 
                    particlesOptions.opacity.value,
                  speedX: (Math.random() - 0.5) * particlesOptions.move.speed * 2,
                  speedY: (Math.random() - 0.5) * particlesOptions.move.speed * 2
                });
              }
            }
          });
        }
      }
    }

    // Helper function to convert hex to rgb
    function hexToRgb(hex) {
      hex = hex.replace('#', '');
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      return `${r}, ${g}, ${b}`;
    }

    // Helper function for deep merge
    function deepMerge(target, source) {
      const output = Object.assign({}, target);
      
      if (isObject(target) && isObject(source)) {
        Object.keys(source).forEach(key => {
          if (isObject(source[key])) {
            if (!(key in target)) {
              Object.assign(output, { [key]: source[key] });
            } else {
              output[key] = deepMerge(target[key], source[key]);
            }
          } else {
            Object.assign(output, { [key]: source[key] });
          }
        });
      }
      
      return output;
    }

    function isObject(item) {
      return (item && typeof item === 'object' && !Array.isArray(item));
    }

    // Initialize
    function init() {
      resizeCanvas();
      addEventListeners();
      animate();
    }

    // Public methods
    this.destroy = function() {
      cancelAnimationFrame(animationFrame);
      window.removeEventListener('resize', resizeCanvas);
      canvas.removeEventListener('mousemove', null);
      canvas.removeEventListener('click', null);
    };

    // Initialize
    init();
  };

  // Make it available globally
  window.ParticlesJS = ParticlesJS;
})();
